<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Realistic CTF Puzzle Simulator - Ultra Hard Mode</title>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: monospace, monospace;
    margin: 0; padding: 1rem;
  }
  h1, h2 {
    text-align: center;
  }
  #terminal {
    background: #222;
    padding: 1rem;
    max-width: 700px;
    margin: 1rem auto;
    border-radius: 6px;
    height: 350px;
    overflow-y: auto;
    white-space: pre-wrap;
  }
  #cmdInput {
    max-width: 700px;
    margin: 0 auto;
    display: flex;
    gap: 0.5rem;
  }
  #cmdInput input {
    flex-grow: 1;
    font-family: monospace;
    font-size: 1.2rem;
    padding: 0.5rem;
    border-radius: 4px;
    border: none;
    background: #222;
    color: #eee;
  }
  #cmdInput button {
    font-family: monospace;
    font-size: 1.2rem;
    padding: 0.5rem 1rem;
    background: #4af;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    color: black;
    font-weight: bold;
    transition: background-color 0.3s;
  }
  #cmdInput button:hover {
    background: #2a8;
  }
  #status {
    max-width: 700px;
    margin: 0.5rem auto;
    background: #222;
    padding: 0.5rem;
    border-radius: 4px;
    font-weight: bold;
  }
  #terminal .prompt {
    color: #4af;
  }
  #terminal .error {
    color: #f66;
  }
  #terminal .success {
    color: #6f6;
  }
  #terminal .info {
    color: #aaa;
  }
</style>
</head>
<body>

<h1>Realistic CTF Puzzle Simulator - Ultra Hard Mode</h1>

<div id="terminal" tabindex="0"></div>

<div id="cmdInput">
  <input id="command" placeholder="Type command here (e.g. nmap 192.168.143.85)" autocomplete="off" spellcheck="false" />
  <button id="runBtn">Run</button>
</div>

<div id="status"></div>

<script>
(() => {
  const terminal = document.getElementById('terminal');
  const cmdInput = document.getElementById('command');
  const runBtn = document.getElementById('runBtn');
  const statusDiv = document.getElementById('status');

  // Base64 encoded IP
  const targetIP = 'MTkyLjE2OC4xNDMuODU='; // 192.168.143.85
  const decodedIP = atob(targetIP);

  // FTP credentials encrypted with XOR cipher
  const ftpUsers = ['rro', 'root'];
  // XOR key for FTP password encryption (hidden in riddle)
  const xorKey = 0x5A;
  // Encrypted passwords (each char XORed with xorKey)
  const ftpPasswordsEncrypted = {
    'rro': [59, 51, 48, 49, 41, 44],      // "hunter2" XORed
    'root': [32, 51, 39, 38, 9, 39, 43]  // "toor123" XORed
  };
  // Decrypt XORed password
  function xorDecrypt(arr) {
    return arr.map(c => String.fromCharCode(c ^ xorKey)).join('');
  }
  const ftpPasswords = {
    'rro': xorDecrypt(ftpPasswordsEncrypted['rro']),
    'root': xorDecrypt(ftpPasswordsEncrypted['root'])
  };

  const sshUser = 'admin';
  const sshPasswordPlain = 'S3cr3tC0d3';

  // SHA-256 hash of sshPasswordPlain (precomputed)
  const sshPasswordHashHex = '258eecf31c324bf729a4cc04b4e457f8d66e467a9efcf3a0d9e0d7a52f93a7e3';

  // Helper: convert string to hex sha-256 hash
  async function sha256Hex(str) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
  }

  let ftpLoggedInUser = null;
  let sshLoggedIn = false;
  let sshAttempts = 0;
  const maxSshAttempts = 3;
  let sshLockUntil = 0;

  // Cookie helpers with Base64 encoded key and value requirement
  function setCookie(name, value, days = 1) {
    const expires = new Date(Date.now() + days*24*60*60*1000).toUTCString();
    document.cookie = `${name}=${value}; expires=${expires}; path=/`;
  }
  function getCookie(name) {
    const cookies = document.cookie.split(';').map(c => c.trim());
    for (const cookie of cookies) {
      if (cookie.startsWith(name + '=')) {
        return cookie.substring(name.length + 1);
      }
    }
    return null;
  }

  // For this hard mode, cookie must be set with base64 encoded key/value pair:
  // key = 'access_key' base64 encoded => YWNjZXNzX2tleQ==
  // value = 'OpenSesame' base64 encoded => T3BlblNlc2FtZQ==
  function checkAccessCookie() {
    const b64Key = 'YWNjZXNzX2tleQ==';
    const b64Val = 'T3BlblNlc2FtZQ==';
    return getCookie(atob(b64Key)) === atob(b64Val);
  }
  function checkFtpCookie() {
    return getCookie('ftp_access') === 'Granted';
  }

  // Terminal print helpers
  function printTerminal(text, type = '') {
    const span = document.createElement('span');
    if (type) span.classList.add(type);
    span.textContent = text + '\n';
    terminal.appendChild(span);
    terminal.scrollTop = terminal.scrollHeight;
  }

  function printPrompt() {
    printTerminal('> ', 'prompt');
  }

  function setStatus(msg, isError = false) {
    statusDiv.textContent = msg;
    statusDiv.style.color = isError ? '#f66' : '#6f6';
  }

  function clearTerminal() {
    terminal.textContent = '';
  }

  // Decoding riddle for cookie command hint and XOR key hint
  const riddleHint = `
[ RIDDLE ]
"Speak, friend, and enter."
Hint 1: The magic phrase opens the door (set cookie).
Hint 2: Use Base64 encoding for cookie key and value!
Hint 3: FTP passwords are XOR encrypted with key 0x5A.
Hint 4: SSH password hash is SHA-256.
Hint 5: There is a hidden FTP command to unlock secrets.
`;

  // Command aliases to confuse user
  const commandAliases = {
    'nmap': ['nmap', 'scan', 'portscan'],
    'curl': ['curl', 'get'],
    'set-cookie': ['set-cookie', 'cookie-set', 'sc'],
    'ssh': ['ssh', 'connect', 'login'],
    'ftp': ['ftp', 'file-transfer'],
    'ls': ['ls', 'list'],
    'get': ['get', 'download'],
    'logout': ['logout', 'exit', 'bye'],
    'help': ['help', 'h', '?'],
    'clear': ['clear', 'cls'],
  };

  // Utility to find command name from alias
  function findCommand(cmd) {
    for (const key in commandAliases) {
      if (commandAliases[key].includes(cmd)) return key;
    }
    return null;
  }

  // Hidden FTP secret unlock command
  let ftpSecretUnlocked = false;

  async function runCommand(input) {
    const rawCmd = input.trim();
    if (!rawCmd) return;

    // Get command name and args
    const parts = rawCmd.split(' ').filter(Boolean);
    const aliasCmd = parts[0].toLowerCase();
    const cmd = findCommand(aliasCmd);
    const args = parts.slice(1);

    printTerminal('> ' + rawCmd, 'prompt');

    // Handle unknown command
    if (!cmd) {
      if (rawCmd === 'sudo rm -rf /') {
        printTerminal('You dare to run that? Nice try.', 'error');
        setStatus('Fatal command blocked.', true);
        return;
      }
      printTerminal(`Command not found: ${rawCmd}`, 'error');
      setStatus('Try "help" for commands.', true);
      return;
    }

    // Check SSH lock timer
    if (sshLockUntil > Date.now()) {
      printTerminal(`SSH is temporarily locked due to failed attempts. Try again later.`, 'error');
      setStatus('SSH locked.', true);
      return;
    }

    // Command implementations

    if (cmd === 'nmap') {
      if (args.length !== 1 || args[0] !== decodedIP) {
        printTerminal(`Usage: nmap ${decodedIP}`, 'error');
        setStatus('Incorrect nmap usage.', true);
        return;
      }
      printTerminal(`Starting Nmap 7.80 ( https://nmap.org ) at 2025-06-05 12:00
Nmap scan report for ${decodedIP}
Host is up (0.0011s latency).
PORT     STATE SERVICE VERSION
21/tcp   open  ftp     vsftpd 3.0.3
22/tcp   open  ssh     OpenSSH 7.9p1 Debian
80
